<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>PDR: Laboratory 8: x86 Assembly Language, part 1 (64 bit)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../../markdown.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="pdr-laboratory-8-x86-assembly-language-part-1-64-bit">PDR: Laboratory 8: x86 Assembly Language, part 1 (64 bit)</h1>
<p><a href="../index.html">Go up to the Labs table of contents page</a></p>
<h3 id="objective">Objective</h3>
<p>This lab is one of two labs meant to familiarize you with the process of writing, assembling, and linking assembly language code. The purposes of the in-lab and post-lab activities are to investigate how various C++ language features are implemented at the assembly level.</p>
<p>There are both <a href="../lab08-32bit/index.html">32 bit</a> (<a href="../lab08-32bit/index.md">md</a>) and <a href="../lab08-64bit/index.html">64 bit</a> (<a href="../lab08-64bit/index.md">md</a>) versions of this lab. This is the <strong><em>64 bit version</em></strong>.</p>
<h3 id="background">Background</h3>
<p>The Intel x86 assembly language is currently one of the most popular assembly languages and runs on many architectures from the x86 line through the Pentium 4. It is a <a href="http://en.wikipedia.org/wiki/Complex_instruction_set_computing">CISC</a> instruction set that has been extended multiple times (e.g. <a href="http://en.wikipedia.org/wiki/MMX_%28instruction_set%29">MMX</a>) into a larger instruction set. In 2004 it was extended to allow for a 64 bit memory space.</p>
<h3 id="readings">Reading(s)</h3>
<ol type="1">
<li>Read the <a href="../../slides/08-assembly-64bit.html">slides on 64 bit x86</a></li>
<li>The x86 book chapters on <a href="../../book/x86-64bit-asm-chapter.pdf">x86</a> and the <a href="../../book/x86-64bit-ccc-chapter.pdf">C calling convention</a></li>
<li>The <a href="https://www.youtube.com/watch?v=XbZQ-EonR_I">x86 Call Stack</a> introduction from the University of Washington</li>
<li>An optional online reading is <a href="https://www.cs.cmu.edu/~fp/courses/15213-s07/misc/asm64-handout.pdf">x86-64 Machine-Level Programming</a> from CMU, although they use the other assembly language format</li>
<li>An optional <a href="https://medium.com/@connorstack/a-guide-to-x86-calling-convention-824a3236ed65">Medium article</a> stepping through the calling convention once again.</li>
</ol>
<h2 id="procedure">Procedure</h2>
<h3 id="pre-lab">Pre-lab</h3>
<ol type="1">
<li>You should be familiar with the readings described above. They detail the x86 material that this lab requires.</li>
<li>Complete the tutorial, which consists of reading the x86 book chapters on <a href="../../book/x86-64bit-asm-chapter.pdf">x86</a> and the <a href="../../book/x86-64bit-ccc-chapter.pdf">C calling convention</a>.</li>
<li>Read through the <em>Platform Architectures</em> section below, which will guide you on how to edit and/or compile your code, depending on whether you are running Linux or macOS.
<ul>
<li><strong>Note:</strong> Regardless of the OS you're running, you must submit the pre-lab in 64-bit Linux format. Otherwise, your code will not compile, and you will receive a zero for this lab part.</li>
</ul></li>
<li>Look at the vecsum.s program and step through it with the debugger.</li>
<li>Implement product() and power() in x86 assembly in a file called mathlib.s.</li>
<li>Your code must compile with <code>make</code>!
<ul>
<li>You may need to SSH into a lab machine to run your code. To do so, follow the instructions in the SSH/SCP tutorial.</li>
</ul></li>
<li>Files to download: <a href="vecsum.s.html">vecsum.s</a> (<a href="vecsum.s">src</a>), <a href="main.cpp.html">main.cpp</a> (<a href="main.cpp">src</a>), <a href="Makefile.html">Makefile</a> (<a href="Makefile">src</a>)</li>
<li>Files to submit: mathlib.s, mathfun.cpp, Makefile</li>
</ol>
<h3 id="in-lab">In-lab</h3>
<ol type="1">
<li>Make sure you have completed the reading on the C calling convention.</li>
<li>Follow the in-lab instructions in this document. Your assignment is to write a function in x86 assembly called mergeSort. The merge function is provided in mergeSort.s.</li>
<li>Your code must compile with <code>make</code>. It must work on a 64-bit Linux machine.</li>
<li>When finished with the in-lab, begin working on the post-lab report.</li>
<li>Files to download: <a href="mergeSort.s.html">mergeSort.s</a> (<a href="mergeSort.s">src</a>), <a href="testMergeSort.cpp.html">testMergeSort.cpp</a> (<a href="testMergeSort.cpp">src</a>)</li>
<li>Files to submit: mergeSort.s, testMergeSort.cpp, Makefile</li>
</ol>
<h3 id="post-lab">Post-lab</h3>
<ol type="1">
<li>Write a report that explains the topics listed in the post-lab section below. Be sure to address all the issues in each topic!</li>
<li>Files to download: none (other than the results of your pre-lab and in-lab)</li>
<li>Files to submit: postlab8.pdf</li>
</ol>
<hr />
<h2 id="platform-architectures">Platform Architectures</h2>
<h3 id="different-architectures">Different Architectures</h3>
<p>There are three changes that you'll need to make to compile your program, depending on whether you're running 64-bit Linux or 64-bit macOS. <strong>Your code must compile (with <code>make</code>) and run on the submission server, which is a 64-bit Linux machine!</strong></p>
<h4 id="linux">Linux</h4>
<ul>
<li>Name your function <code>vecsum</code>. You'll need to change the name in TWO places:
<ul>
<li>The <code>global</code> line (line 11 of vecsum.s)</li>
<li>The label line (line 15 of vecsum.s)</li>
</ul></li>
<li>Specify the <code>-f elf64</code> flag to <code>nasm</code> (update the <code>AS</code> or <code>ASFLAGS</code> macro in your Makefile accordingly)</li>
<li>Specify the <code>-m64</code> flag to <code>clang++</code> (update the <code>CXX</code> or <code>CXXFLAGS</code> macro in your Makefile accordingly)</li>
<li><strong>Note:</strong> If you're using your own Linux installation (if you're not using the VirtualBox image) and are running into issues, try installing the <code>g++-multilib</code> package
<ul>
<li>Even though we're no longer using the <code>g++</code> compiler in this course, it will install the correct library in the correct place</li>
<li>Please let us know if this differs with your version of Linux!</li>
</ul></li>
</ul>
<h4 id="macos">macOS</h4>
<ul>
<li>Name your function <code>_vecsum</code>. You'll need to change the name in TWO places:
<ul>
<li>The <code>global</code> line (line 11 of vecsum.s)</li>
<li>The label line (line 15 of vecsum.s)</li>
<li>If you don't do this, you might get an error like: <code>main.cpp:(.text+0x12): undefined reference to 'vecsum'</code></li>
</ul></li>
<li>Specify the <code>-f macho64</code> flag to <code>nasm</code> (update the <code>AS</code> or <code>ASFLAGS</code> macro in your Makefile accordingly)</li>
<li>We're unsure about the <code>clang++</code> flags necessary, and you might not be able to print the assembly in the format discussed in class</li>
<li><strong>IMPORTANT:</strong> Please test your code on a 64-bit Linux machine (such as the VirtualBox image) before submitting it. In order to do so, you'll need to change everything back to meet the Linux requirements.</li>
<li><strong><em>WARNING:</em></strong> As mentioned in the class introduction (specifically, <a href="../../uva/course-introduction.html#/unixinfo">here</a>), some parts of this lab may <strong>NOT</strong> be compatible with macOS. So if things aren't working, or these directions are running into issues, consider reverting to the VirtualBox image.</li>
</ul>
<p><strong>Do NOT specify a <code>-o</code> flag to clang++ (not even <code>-o a</code>)</strong>, as we want it to be named the default (a.out).</p>
<p><strong>REMINDER:</strong> You MUST submit your code in 64-bit Linux format, and it must compile!</p>
<hr />
<h2 id="pre-lab-1">Pre-lab</h2>
<h3 id="compiling-assembly-with-c">Compiling Assembly With C++</h3>
<p>For this part, you will need to download three files: <a href="vecsum.s.html">vecsum.s</a> (<a href="vecsum.s">src</a>), <a href="main.cpp.html">main.cpp</a> (<a href="main.cpp">src</a>), and <a href="Makefile.html">Makefile</a> (<a href="Makefile">src</a>).</p>
<p>To compile a program written partly in x86 assembly and partly in C++, we have to build the program in parts.</p>
<p>First, we build the C++ file as we have in the past:</p>
<pre><code>clang++ -m64 -Wall -g -c -o main.o main.cpp</code></pre>
<ul>
<li><code>-c -o main.o</code>: compiles main.cpp (but doesn't link it) and puts the compilation output into a file named main.o</li>
<li><code>-m64</code>: tells <code>clang++</code> to compile main.cpp in 64-bit format</li>
<li><code>-Wall</code>: prints all compile warnings</li>
<li><code>-g</code>: compile with debugging information</li>
</ul>
<p>Next, we compile the assembly file (<code>nasm</code> is the assembler we're using in this course):</p>
<pre><code>nasm -f elf64 -g -o vecsum.o vecsum.s</code></pre>
<ul>
<li><code>-o vecsum.o</code>: puts the assembler output in a file named vecsum.o</li>
<li><code>-f elf64</code>: specifies the output format (elf64) for the final executable
<ul>
<li>For macOS, use <code>-f macho64</code> instead (see the Platform Architectures section above)</li>
</ul></li>
</ul>
<p>Finally, we have to link the two .o files into the final executable a.out:</p>
<pre><code>clang++ -m64 -Wall -g vecsum.o main.o</code></pre>
<h3 id="tutorial">Tutorial</h3>
<p>Complete the C++/assembly tutorial, which consists of reading the book chapters on <a href="../../book/x86-64bit-asm-chapter.pdf">x86-64</a> and the <a href="../../book/x86-64bit-ccc-chapter.pdf">calling convention</a>. Another good reading is <a href="https://www.cs.cmu.edu/~fp/courses/15213-s07/misc/asm64-handout.pdf">x86-64 Machine-Level Programming</a> from CMU. (The CMU reading uses the other assembly language format.)</p>
<h3 id="vecsum">Vecsum</h3>
<p>Examine the vecsum subroutine in <a href="vecsum.s.html">vecsum.s</a> (<a href="vecsum.s">src</a>). Use the slides and readings to help understand what is happening in vecsum.s. Make sure you understand the prologue and epilogue implementation, as well as the instructions used in the subroutine.</p>
<p>Compile and run the vecsum program:</p>
<ul>
<li>If you forget the lldb commands described below, see the <a href="../../docs/lldb_summary.html">LLDB command summary</a>, which has a summary of all of these commands.</li>
<li>Set a breakpoint at the line in main.cpp where the vecsum() function is called (line 45).</li>
<li>Enter <code>stepi</code> to step to the next assembly instruction (NOT <code>step</code> - that will step to the next C++ instruction).</li>
<li>Enter <code>settings set target.x86-disassembly-flavor intel</code>. This will change the format of the assembly code to the one we're used to.
<ul>
<li>Note that you'll have to enter this command every time you exit and re-enter LLDB.</li>
</ul></li>
<li>Enter <code>disassemble</code> to view the assembly code currently being executed.
<ul>
<li>To see the vecsum function, enter <code>disassemble --name vecsum</code>.</li>
<li>Note that this only lists the first third (or so) of the routine -- up until the <code>start</code> label.</li>
<li>To see the rest of the code, enter <code>disassemble --name start</code>, <code>disassemble --name done</code>, etc.</li>
</ul></li>
<li>To show the contents of the registers, use the <code>info registers</code> command.</li>
</ul>
<h3 id="pre-lab-program">Pre-lab program</h3>
<p>For the pre-lab, you'll need to submit two files: an assembly file called mathlib.s, and a C++ file called mathfun.cpp.</p>
<h4 id="mathlib.s">mathlib.s</h4>
<p>Implement the two following subroutines:</p>
<ul>
<li><code>product</code> (calculates the product of two integers)
<ul>
<li>Must be defined <strong>iteratively</strong></li>
<li>Must ONLY use addition</li>
<li>Cannot use <code>imul</code> or any built-in multiplication routine</li>
<li>Must use the proper C-style calling convention</li>
</ul></li>
<li><code>power</code> (calculates the power of the first integer to the second integer)
<ul>
<li>Must be defined <strong>recursively</strong></li>
<li>Must call <code>product</code></li>
<li>Cannot use <code>imul</code> or any built-in exponentiation routine</li>
<li>Must use the proper C-style calling convention</li>
</ul></li>
</ul>
<p>Make sure to declare both of these subroutines with <code>global</code> at the top of the file, so that mathfun.cpp can call them. You'll need two <code>global</code> lines, one for each subroutine.</p>
<p>You can assume the following:</p>
<ul>
<li>The numbers passed into both routines are positive (you don't need to account for negative numbers or zero)</li>
<li>We will not provide your program with input that will cause an integer overflow</li>
</ul>
<h4 id="mathfun.cpp">mathfun.cpp</h4>
<ul>
<li>Must call both of your subroutines
<ul>
<li>Make sure to declare your assembly routines with <code>extern &quot;C&quot;</code>, just like in the provided main.cpp file.</li>
</ul></li>
<li>Read integers via standard input (<code>cin</code>), NOT command-line parameters
<ul>
<li>Must take in ONLY two integers</li>
<li>Must print the result of calling <code>product</code> and <code>power</code> on the two integers</li>
</ul></li>
</ul>
<p>Example test run:</p>
<pre><code>Enter a number: 3
Enter another number: 4
12
81</code></pre>
<p>If you need help, see the provided <code>main.cpp</code> file as a template.</p>
<hr />
<h2 id="in-lab-1">In-lab</h2>
<p>Before You Start:</p>
<ul>
<li>Make sure you understand your pre-lab code.
<ul>
<li>Ask a TA if you have any questions.</li>
<li>Make sure you understand how to write recursive functions in assembly, as you'll be required to do so on the exam.</li>
</ul></li>
<li>Read and understand the C calling convention.</li>
</ul>
<p>You'll need to submit three files for the in-lab: an assembly file called mergeSort.s, an <strong>UNMODIFIED</strong> C++ file called testMergeSort.cpp, and a Makefile.</p>
<h4 id="mergesort.s">mergeSort.s</h4>
<ul>
<li>Download the file <a href="mergeSort.s.html">mergeSort.s</a> (<a href="mergeSort.s">src</a>).</li>
<li>Implement the <code>mergeSort</code> method.
<ul>
<li><code>mergeSort</code> is a <code>void</code> method (it has no return type, as it modifies the original array). It takes three parameters in the following order:
<ul>
<li>A pointer to an int array (<code>int*</code>)</li>
<li>An integer corresponding to the left index of the array</li>
<li>An integer corresponding to the right index of the array</li>
</ul></li>
</ul></li>
<li><strong>NOTE:</strong> We have already provided a fully implemented <code>merge</code> method. This method makes use of two caller-saved registers, r10 and r11. <strong>Remember to save and restore these registers</strong> before and after calling <code>merge</code>.</li>
</ul>
<h4 id="testmergesort.cpp">testMergeSort.cpp</h4>
<ul>
<li>Download the file <a href="testMergeSort.cpp.html">testMergeSort.cpp</a> (<a href="testMergeSort.cpp">src</a>).</li>
<li><strong>DO NOT</strong> change this file.</li>
<li>This is a C++ program for testing your merge sort implementation.
<ul>
<li>It reads input via <code>cin</code> (standard input), not command-line parameters.</li>
<li>You'll have to enter the array size, and then each array element one by one.</li>
<li>It will call <code>mergeSort</code> on your array and print the result.</li>
<li>Make sure to test your implementation on multiple array sizes.</li>
</ul></li>
<li>You can assume the following:
<ul>
<li>The array size is nonzero.</li>
</ul></li>
</ul>
<h4 id="makefile">Makefile</h4>
<ul>
<li>You can copy your pre-lab Makefile and set <code>OFILES=mergeSort.o testMergeSort.o</code>.</li>
</ul>
<h3 id="resources">Resources</h3>
<ul>
<li>Click <a href="https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/tutorial/">here</a> for an explanation of the merge sort algorithm.</li>
</ul>
<h3 id="sample-execution-run">Sample Execution Run</h3>
<p>Below is a sample execution run to show you the input and output format we are looking for.</p>
<pre><code>Enter the array size: 5
Enter value 0: -7
Enter value 1: 2
Enter value 2: -39
Enter value 3: 12
Enter value 4: 8
Unsorted array: -7 2 -39 12 8
Sorted array: -39 -7 2 8 12</code></pre>
<p><strong>If you finish the in-lab early, you should begin working on the post-lab report.</strong></p>
<hr />
<h2 id="post-lab-1">Post-lab</h2>
<p>For the post-lab, you should investigate and understand the topics below, and prepare a report that explains your findings. Follow the guidelines in the Post-lab Report Guideline section.</p>
<h3 id="report-format">Report Format</h3>
<ul>
<li>Should be a PDF file called postlab8.pdf
<ul>
<li>Click <a href="../../docs/convert_to_pdf.html">here</a> for details about creating a PDF file.</li>
</ul></li>
<li>Should be single-spaced.</li>
<li>Create two numbered lists containing the various topics, one for each section, like the following:
<ul>
<li><pre><code>Parameter passing
1.
2.
3.
4.

Objects
1.
2.
3.
4.
5.</code></pre></li>
<li>For each list item, include a 1 to 2 paragraph (maximum) explanation and at least one piece of evidence.
<ul>
<li>Assembly code, C++ code, screenshots, memory dumps, console output, etc. count as evidence.</li>
</ul></li>
</ul></li>
<li>Include a <em>Sources</em> section.</li>
</ul>
<h3 id="external-resources">External Resources</h3>
<ul>
<li><strong>You must use (and cite!) at least TWO additional resources for this post-lab!</strong></li>
<li><em>The following resources count as external</em>: books, reputable websites, x86 assembly resources, and other resources on the Internet (outside the course)</li>
<li><em>The following resources do <strong>NOT</strong> count as external</em>: lecture, the TAs</li>
</ul>
<h3 id="tips-for-getting-started">Tips for Getting Started</h3>
<p>Think about how best to investigate the issues you choose. The following steps might give you an idea of how to start:</p>
<ol type="1">
<li>Write a small C++ program that illustrates one of the issues. This program should be as simple as possible. You may want to create a simple class (include several methods and at least 5 data members of different types and access levels - <code>public</code> and <code>private</code>).</li>
<li>Look at the assembly code associated with your C++ code. You can examine this code in one of multiple ways:
<ul>
<li>Step through the code in the debugger using <code>stepi</code> (step to the next assembly instruction) and <code>disassemble</code> (view the current assembly code being executed), OR</li>
<li>Output the assembly code to a .s file using <code>clang++ -S -mllvm --x86-asm-syntax=intel -fomit-frame-pointer fileName.cpp</code> (and view the file in Emacs), OR</li>
<li>Use the site <a href="https://www.godbolt.org">www.godbolt.org</a> to view the assembly code.
<ul>
<li>You can paste your C++ code directly into the editor, or upload a file.</li>
<li>Choose either clang or gcc as your compiler.</li>
</ul></li>
</ul></li>
</ol>
<p>Another tip to discover some findings is to make small modifications to your C++ code, and compare the generated assembly code <em>before</em> and <em>after</em> your changes.</p>
<h3 id="report-topics">Report Topics</h3>
<p>The questions below are what you must address in your post-lab report. Make sure you answer each part and include sufficient evidence.</p>
<p><strong>You may discuss these topics, but your code and final report must be your own work and that you must credit ANY resources used.</strong></p>
<h4 id="parameter-passing">Parameter Passing</h4>
<p>For each of these topics, show and explain the following:</p>
<ul>
<li>The assembly code generated by the compiler (for a simple function and function call that passes parameters by a variety of means).</li>
<li>What's happening in the caller and in the callee.
<ul>
<li>You don't need to describe parts of the C calling convention we described in class</li>
</ul></li>
</ul>
<ol type="1">
<li>How are variables (ints, chars, pointers, floats, etc.) passed by value? How are they passed by reference?
<ul>
<li>Create several functions and examine the parameter registers to help you answer this question.</li>
</ul></li>
<li>Create a simple function that takes in an object.
<ul>
<li>How are objects passed by value?</li>
<li>How are they passed by reference?</li>
<li>Specifically, what is contained in the parameter registers in each case?</li>
</ul></li>
<li>Create an array in your main method, and write a function that takes it in as a parameter.
<ul>
<li>How are arrays passed into functions?</li>
<li>How does the callee access the parameters?</li>
<li>Where are the data values placed?</li>
<li><strong>Hint:</strong> you will need to determine at least a register-relative address.</li>
</ul></li>
<li>Is passing values by reference different than passing by pointer? If they are the same, what exactly is passed in the parameter register? If they are different, how so?</li>
</ol>
<h4 id="objects">Objects</h4>
<ol type="1">
<li>Create an object in your main method, and view where each data member is located in memory.
<ul>
<li>How is object data laid out in memory?</li>
<li>How does C++ keep different fields of an object &quot;together&quot;?</li>
</ul></li>
<li>Explain how data member access works for objects.
<ul>
<li>How does the assembly know which data member to access?</li>
<li>We know how local variables and parameters are accessed (offsets from the base pointer) -- describe how this is done for data fields.</li>
</ul></li>
<li>How does method invocation work for objects?
<ul>
<li>Specifically, how does the assembly know which object it is being called out of?</li>
<li>Remember that assembly is <strong>NOT</strong> object oriented.</li>
</ul></li>
<li>How are data members accessed both from inside a member function and from outside?
<ul>
<li>Describe what the assembly code does to access data members in both of these situations.</li>
</ul></li>
<li>How are public member functions accessed for your class?
<ul>
<li>Call some of the public member functions for your class and examine the parameters.</li>
<li>How is the &quot;this&quot; pointer implemented?
<ul>
<li>Where is it stored?</li>
<li>When is it accessed?</li>
<li>How is it passed to member functions?</li>
</ul></li>
</ul></li>
</ol>
<p><strong>Your grade will be based on whether you sufficiently answered and provided evidence for the above questions.</strong></p>
</body>
</html>
